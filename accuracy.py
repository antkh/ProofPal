# -*- coding: utf-8 -*-
"""Accuracy.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1IijdyvAi4m-J5SbPtwLSOzWF8U7DAmd_

# Code from before:
"""

def show_state(S): # Converts our vectorized state to readable logical formula
  First = True
  for statement in S:
    if not First:
      print(" & ", end="")
    else:
      First = False
    print("( ", end="")
    first = True
    for clause in statement:
      if not first:
        print(" v ", end="")
      else:
        first = False
      print(show_clause(clause), end="")

    print(" )", end="")

predMap = {1:"P", 2:"Q", 3:"R"}
varMap = {1:"x", 2:"y", 3:"z", -1:"a", -2:"b", -3:"c", -4:"d", -5:"e", -6:"i", -7:"j"}
funMap = {1:"f", 2:"g"}

def show_clause(c):
  res = ""
  if c[0] < 0:
    res += "~"
  res += predMap[abs(c[0])] + "("
  if c[2] != 0:
    res += funMap[c[2]] + "(" + varMap[c[1]] + ")"
  else:
    res += varMap[c[1]]
  res += ")"
  return res

import numpy as np
from collections import defaultdict
import random


class Proof:
    def __init__(self):
        pass

    def reset_real(self, statements, NEXT_UNUSED_INSTANCE, num_functions):
        self.state = statements
        self.n = len(self.state)
        self.NEXT_UNUSED_INSTANCE = NEXT_UNUSED_INSTANCE
        self.num_functions = num_functions
        return self.state



    def extend(self, i, j):
        if i >= self.n or j >= self.n:
            return False

        p = self.state[i]
        q = self.state[j]

        if len(p) == 1 and len(q) > 1 and (p[0][0] * -1, p[0][1], p[0][2]) in q:
            q.remove((-1*p[0][0], p[0][1], p[0][2]))
            self.state[j] = q # msh aayzina sah?

            return True
        else:
            return False

    def contradict(self, i, j):
        if i >= self.n or j >= self.n:
            return False
        p = self.state[i]
        q = self.state[j]

        if len(p) == 1 and len(q) == 1 and (p[0][0], p[0][1], p[0][2]) == (-1 * q[0][0], q[0][1], q[0][2]):
            return True

        else:
            return False

    def instantiate(self, i, uni_var, inst):
        if i >= self.n:
            return False

        if inst <= self.NEXT_UNUSED_INSTANCE: # this instance hasn't been introduced yet
            return False

        p = self.state[i]
        q = []

        changed = False
        for c in p:
            if c[1] == uni_var:
                q.append((c[0], inst, c[2]))
                changed = True
            else:
                q.append(c)

        if changed:
            for f in range(1, self.num_functions+1): # give instances to functions of instances
                u = self.NEXT_UNUSED_INSTANCE
                used = False
                for c in range(len(q)):
                    if q[c][2] == f:
                        q[c] = (q[c][0], u, 0)
                        used = True
                if used:
                    self.NEXT_UNUSED_INSTANCE -= 1

        if changed and q not in self.state:
            self.state.append(q)
            self.n += 1
            return True
        else:
          return False # if uni_var was not in i


def encode_state(state):
    """Encodes the state as a hashable tuple, ignoring order at the top level but preserving it in nested lists."""

    def to_tuple(lst):
        """Recursively converts lists to tuples."""
        if isinstance(lst, list):
            return tuple(to_tuple(item) for item in lst)
        else:
            return lst

    state_tuple = to_tuple(state)  # Convert to a tuple using to_tuple
    sorted_tuple = tuple(sorted(state_tuple, key=lambda x:x[0][0]))
    return sorted_tuple

import copy

EPISODES = 10000

EPS = 1
EPS_DECAY = 0.995
MIN_EPS = 0.1

ALPHA = 0.1
GAMMA = 0.9

MAX_ITER = 100

def get_qtable(env_initial, n_Pred, n_Vars_Uni, n_Vars_Inst, n_Funs, n_Statements):

    num_applications = 2**n_Funs # number of useful possible applications to instances
    num_instance = n_Vars_Inst * num_applications # number of all generatable instances, including applications of functions to instances


    N = 2*n_Statements # MAXIMUM number of statements allowed to be in state


    num_actions = 2*N*(N-1) + N * num_instance * n_Vars_Uni


    q_table = defaultdict(lambda: [0] * (num_actions))



    def choose_action(state_idx, eps):
      if random.random() < eps:
          return random.choice([i for i in range(num_actions)])
      else:
          return max(range(num_actions), key= lambda a: q_table[state_idx][a]) # returns action which maximizes the function key


    env = Proof()
    for episode in range(EPISODES):

      state = env.reset_real(copy.deepcopy(env_initial), n_Vars_Inst*(-1) - 1, n_Funs)

      done = False

      eps = max(MIN_EPS, EPS * (EPS_DECAY ** episode))

      iters = 0

      while not done and iters < MAX_ITER:

          iters += 1

          state_idx = encode_state(state)

          action = choose_action(state_idx, eps)

          next_state_idx = state_idx
          next_state = state

          if action < N*(N-1): # extend
              i = action // (N-1)
              j = action % (N-1)
              if j >= i: # beacause N-1 choices
                  j += 1

              if env.extend(i, j):
                  next_state = env.state
                  next_state_idx = encode_state(next_state)
                  reward = -1
              else:
                  reward = -2


          elif action < 2*N*(N-1): # contradiction
              action -= N*(N-1)
              i = action // (N-1)
              j = action % (N-1)
              if j >= i: # beacause N-1 choices
                  j += 1

              action += N*(N-1)  # restore value

              if env.contradict(i, j):
                  done  = True
                  reward = 100
              else:
                  reward = -2

          else: # instantiate
              action -= 2*N*(N-1) # = N * num_instance * num_uni_vars

              i = action // (num_instance * n_Vars_Uni)
              t = action % (num_instance * n_Vars_Uni)
              uni_var = t // num_instance + 1
              inst = (t % num_instance + 1) * -1

              action += 2*N*(N-1)


              if env.instantiate(i, uni_var, inst):
                  next_state = env.state
                  next_state_idx = encode_state(next_state)
                  reward = -1
              else:
                  reward = -2



          if iters == MAX_ITER:
              reward -= 100

          # update q-values
          max_next_q = max(q_table[tuple(next_state_idx)])
          q_table[state_idx][action] += ALPHA * (reward + GAMMA * max_next_q - q_table[state_idx][action])


          state = next_state


    return q_table

def getProof(env_initial, n_Pred, n_Vars_Uni, n_Vars_Inst, n_Funs, n_Statements):
    # same as previous function, but always uses the Q-Table to decide on the next action (i.e., no exploration, just exploitation)

    num_applications = 2**n_Funs # number of useful possible applications to instances
    num_instance = n_Vars_Inst * num_applications # number of all generatable instances, including applications of functions to instances

    N = 2*n_Statements # MAXIMUM number of statements allowed to be in state

    num_actions = 2*N*(N-1) + N * num_instance * n_Vars_Uni


    q_table = get_qtable(copy.deepcopy(env_initial), n_Pred, n_Vars_Uni, n_Vars_Inst, n_Funs, n_Statements)

    env = Proof()
    state = env.reset_real(copy.deepcopy(env_initial), n_Vars_Inst*(-1) - 1, n_Funs)

    done = False
    iters = 0

    print("Initial Environment: ", end = "")
    show_state(state)
    print()

    while not done:
        if iters == 100:
            print("Max iters exceeded")
            break
        iters += 1

        state_idx = encode_state(state)
        action = max(range(num_actions), key= lambda a: q_table[state_idx][a])

        next_state_idx = state_idx
        next_state = state

        if action < N*(N-1): # extend
            i = action // (N-1)
            j = action % (N-1)
            if j >= i: # beacause N-1 choices
                j += 1

            if env.extend(i, j):
                next_state = env.state
                next_state_idx = encode_state(next_state)
                print("Updated Environment: ", end = "")
                show_state(state)
                print()
            else:
                print("Bad indices in extension: ", i, j)

        elif action < 2*N*(N-1): # contradiction
            action -= N*(N-1)
            i = action // (N-1)
            j = action % (N-1)
            if j >= i: # beacause N-1 choices
                j += 1

            action += N*(N-1)  # restore value

            if env.contradict(i, j):
                done  = True
                print("Contradiction Found")
            else:
                print("Bad indices in contradiction: ", i, j)

        else: # instantiate
            action -= 2*N*(N-1) # = N * num_instance * num_uni_vars

            i = action // (num_instance * n_Vars_Uni)
            t = action % (num_instance * n_Vars_Uni)
            uni_var = t // num_instance + 1
            inst = (t % num_instance + 1) * -1

            action += 2*N*(N-1)


            if env.instantiate(i, uni_var, inst):
                next_state = env.state
                next_state_idx = encode_state(next_state)
                print("Updated Environment: ", end = "")
                show_state(state)
                print()
            else:
                print("Bad indices in instantiation: ", i, uni_var, inst)


        state = next_state

"""# Accuracy Calculation

We use the randomly generated sample of statements from GenerateSample.ipynb, which was saved in data.json. We run our algorithm on the data, and compare the results to Tree Proof Generator (https://www.umsu.de/trees/), which is a deterministic algorithm.

Our accuracy will be how similar our obtained results are to the correct results.
"""

import json

with open('data.json', 'r') as file:
    data = json.load(file)

print("List:", data)

result = []
shortened_data = data[0:10]

iteration = 1

for datum in shortened_data:
  print("Iteration " + str(iteration) + ":")
  result.append(getProof(datum, 3, 2, 2, 2, len(datum)))
  iteration += 1

print(result)